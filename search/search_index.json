{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>This is just a placeholder file for the webpage to re-direct to the introduction.md file.</p>"},{"location":"arduino_example/","title":"Arduino Example","text":"<p>Now that we've installed the espressif boards package in Arduino, it's time to upload our first sketch to make sure everything is working properly.</p>"},{"location":"arduino_example/#example-1-blink","title":"Example 1 - Blink","text":"<p>This basic example makes sure the board package installed correctly and the board accepts programming properly to blink the blue STAT LED on the board every second. Open the example in Arduino by navigating to File &gt; Examples &gt; Basics &gt; 01-Blink.</p> <p>USB CDC On Boot Settings</p> <p>Take note of the option labeled \"USB CDC on Boot\" when selecting the Board from the Tools menu. This option sets the serial outputs and defines their label for use in code. The SparkFun variants default to Enable USB CDC on boot which sets both <code>Serial</code> and <code>Serial0</code> as available serial ports. In this configuration, <code>Serial</code> corresponds to the direct USB/Serial converter on the chip (and the USB-C interface) and <code>Serial0</code> corresponds to the UART0 bus (default pins are 16 and 17).</p> <p>With either setting, <code>Serial1</code> is available and refers to the UART1 bus (default pins are 4 and 5).</p> <p>Select the board (SparkFun ESP32-C6 Qwiic Pocket) and Port and click \"Upload\". After uploading you should see the STAT LED on the board blinking every second.</p>"},{"location":"hard_copy/","title":"Hard Copies","text":"<p>Need to download or print our hookup guide?</p> <ul> <li>Print  from Single-Page View</li> </ul>"},{"location":"hardware_assembly/","title":"Hardware Assembly","text":""},{"location":"hardware_assembly/#basic-usb-assembly","title":"Basic USB Assembly","text":"<p>Basic assembly of the Qwiic Pocket Development Board only requires a USB-C cable connecting the board to a computer. Just plug the cable into the USB-C connector like the photo below shows and move on to the Software Setup section. </p> <p></p> <p>Note</p> <p>Your computer may not recognize the board as a known USB device if you have not installed the espressif boards package in Arduino and/or installed the espressif IDF.</p>"},{"location":"hardware_assembly/#battery-assembly","title":"Battery Assembly","text":"<p>If you prefer a battery-powered application, plug a single-cell LiPo battery into the 2-pin JST connector on the underside of the board like the photo below. Remember, the MCP73831 only charges the battery when V_USB has voltage present either from the USB-C connector or through the V_USB PTH pin.</p> <p></p> <p>For tips on the proper use of a LiPo battery and the 2-pin JST connector, please read through our Single Cell LiPo Battery Care tutorial.</p>"},{"location":"hardware_overview/","title":"Hardware Overview","text":"<p>Let's take a closer look at the ESP32-C6 module and other hardware on the Qwiic Pocket Development Board.</p>"},{"location":"hardware_overview/#esp32-c6-mini-1-module","title":"ESP32-C6 Mini-1 Module","text":"<p>The ESP32-C6 Mini-1 module from espressif features a 32-bit RISC-V single-core processor with an integrated wireless stack. The wireless stack is compatible with 2.4 GHz WiFi 6, Bluetooth<sup>\u00ae</sup> 5.3, Zigbee and Thread (802.15.4) and uses an on-board PCB antenna.</p> <p></p> <p>This development board uses the Mini version of the C6 module which has slightly less computing power in exchange for greater power efficiency. This makes this module perfect for battery-powered applications. The module features a wide range of peripheral options including SPI, UART, LPUART, I<sup>2</sup>C, I<sup>2</sup>S, LED PWM, USB Serial/JTAG controller, ADC and more. Many of these peripherals can be mapped to any GPIO pin though some are tied to specific pins. Refer to the datasheet for a complete overview of the ESP32-C6-MINI-1.</p> <p>The ESP32-C6 has 4 MB Flash memory along with 512 KB SRAM (high power)/ 16 KB SRAM (low power). The module uses pin strapping to configure boot mode parameters. The board defaults to standard mode (GPIO 9 internal pull-up, all other strapping pins floating) but it can be set to other parameters by performing the following pin strapping:</p> <ul> <li>SDIO Sampling and Driving Clock Edge - MTMS &amp; MTDI</li> <li>Chip Boot Mode - GPIO8 &amp; GPIO9</li> <li>ROM Code Printing to UART - GPIO8</li> <li>JTAG Signal Source - GPIO15</li> </ul>"},{"location":"hardware_overview/#power-components","title":"Power Components","text":""},{"location":"hardware_overview/#usb-c-connector","title":"USB-C Connector","text":"<p>The USB-C connector on the board acts as the primary serial interface for the ESP32-C6 module as well as a power input. It connects directly to the ESP32-C6's USB serial converter. The 5V USB input voltage is regulated down to 3.3V through a voltage regulator with a max current of 500mA@3.3V.</p> <p></p>"},{"location":"hardware_overview/#jst-connector-battery-charger","title":"JST Connector &amp; Battery Charger","text":"<p>The board has a 2-pin JST connector to connect a single-cell Lithium Ion (LiPo) battery for battery-powered applications. It also has an MCP73831 battery charger to charge an attached battery. The charge rate is set to 214mA@3.3V. The MCP73831 receives power from the V_USB line so it only is powered when 5V is provided either over USB or the V_USB PTH pin. If applying voltage directly to the V_USB pin make sure it does not exceed 5.5V.</p> <p></p>"},{"location":"hardware_overview/#pinout-qwiic-connector","title":"Pinout &amp; Qwiic Connector","text":""},{"location":"hardware_overview/#pth-pins","title":"PTH Pins","text":"<p>The Qwiic Dev Board routes eight GPIO pins to a pair of 0.1\"-spaced PTH headers. One side has 3.3V and GND pins along with I/O pins 2, 3, 4, and 5. The other side has through-holes for V_USB and VBatt as well as I/O pins 16 (TX), 17 (RX), 18, and 19.</p> <p></p>"},{"location":"hardware_overview/#qwiic-connector","title":"Qwiic Connector","text":"<p>There's a Qwiic connector on the board tied to the ESP32-C6's Low Power I<sup>2</sup>C bus (I/O pins 6 and 7) for easy integration into SparkFun's Qwiic ecosystem. The Qwiic connector provides connections for SDA, SCL, 3.3V, and Ground.</p> <p></p>"},{"location":"hardware_overview/#buttons","title":"Buttons","text":"<p>There are two buttons on the board labeled RESET and BOOT. The RESET button is tied to the ESP32-C6's Enable (EN) pin and resets the module when pressed. The BOOT button puts the ESP32-C6 into bootloader mode when held down during power on or reset.</p> <p></p>"},{"location":"hardware_overview/#leds","title":"LEDs","text":"<p>The board has three LEDs labeled PWR, STAT, and CHG. The red Power (PWR) LED indicates whenever the 3.3V circuit is powered. The blue Status (STAT) LED is tied to IO23 on the ESP32. The yellow Charge (CHG) LED indicates whenever the MCP73831 is charging a connected LiPo battery.</p> <p></p>"},{"location":"hardware_overview/#solder-jumpers","title":"Solder Jumpers","text":"<p>There are four solder jumpers on the Qwiic Dev Board labeled CHG, I<sup>2</sup>C, SHLD, and PWR. The table below outlines the jumpers' labels, default state, function, and any notes regarding their use:</p> <p></p> Label Default State Function Notes CHG CLOSED Completes Charge LED circuit Open to disable Charge LED I<sup>2</sup>C CLOSED Pulls the SDA/SCL lines to 3.3V through a pair of 2.2k\u03a9 resistors Three-way jumper. Open completely to disable pullups SHLD CLOSED Ties the USB-C shield pin to the ground plane Open to isolate USB-C shield pin from the board's ground plane PWR CLOSED Completes the Power LED circuit Open to disable the Power LED"},{"location":"hardware_overview/#board-dimensions","title":"Board Dimensions","text":"<p>The Qwiic Dev Board - ESP32-C6 matches the 1\" x 1\" (22.6mm x 22.6mm) Qwiic form factor and has two mounting holes that fit a 4-40 screw. </p> <p></p>"},{"location":"introduction/","title":"Introduction","text":"<ul> <li> <p> SparkFun Qwiic Pocket Development Board - ESP32-C6 SKU: DEV-22925 <p> </p> <p> </p> <li> <p>The SparkFun Qwiic Pocket Development Board - ESP32-C6features the ESP32-C6 Mini-1 module from espressif<sup>\u2122</sup>. The ESP32-C6 SoC is built around a RISC-V single-core processor with 4 MB flash memory and supports 2.4 GHz WiFi 6, Bluetooth<sup>\u00ae</sup> 5 (with Low Energy), Zigbee and Thread 802.15.4 wireless protocols. The module uses an integrated PCB antenna.      The ESP32-C6 includes on-chip serial-to-UART conversion which helps reduce the number of components on the development board so we designed this Qwiic Dev Board to cram as much as we could into the Qwiic system's 1\"x1\" form factor. It also includes a USB-C connector, 2-pin JST connector for a single-cell LiPo battery along with a charging circuit for a connected battery, a Qwiic connector, and it also breaks out eight GPIO pins (including one UART). </p> <p> Purchase from SparkFun  </p> </li>"},{"location":"introduction/#required-materials","title":"Required Materials","text":"<p>To follow along with this guide you will need a USB-C cable to connect the dev board to your computer: </p> <ul> <li> <p> <p> </p> <p> USB 3.1 Cable A to C - 3 Foot CAB-14743 </p> <li> <p> <p> </p> <p> Reversible USB A to C Cable - 2m CAB-15424 </p> <p>You may also want to get a Qwiic cable or kit to connect the Qwiic Dev Board - ESP32-C6 to other Qwiic devices:</p> <ul> <li> <p> <p> </p> <p> Flexible Qwiic Cable - 100mm PRT-17259 </p> <li> <p> <p> </p> <p> Flexible Qwiic Cable - 50mm PRT-17260 </p> <li> <p> <p> </p> <p> Flexible Qwiic Cable - 500mm PRT-17257 </p> <li> <p> <p> </p> <p>Flexible Qwiic Cable - Female Jumper (4-pin) CAB-17261 </p>"},{"location":"introduction/#optional-materials","title":"Optional Materials","text":"<p>The Qwiic Dev Board - ESP32-C6 includes a 2-pin JST connector and integrated charging circuit for an attached single-cell LiPo battery. Below are a few options for batteries we recommend for battery-powered applications:</p> <ul> <li> <p> <p> </p> <p> Lithium Ion Battery - 1250mAh (IEC62133 Certified) PRT-18286 </p> <li> <p> <p> </p> <p> Lithium Ion Battery - 2Ah PRT-13855 </p> <li> <p> <p> </p> <p> Lithium Ion Battery - 400mAh PRT-13851 </p> <li> <p> <p> </p> <p> Lithium Ion Battery - 850mAh PRT-13854 </p> <p>If you prefer a soldered connection or want to modify the solder jumpers on this board, you may need some of the products listed below:</p> <ul> <li> <p> <p> </p> <p> Break Away Headers - Straight PRT-00116 </p> <li> <p> <p> </p> <p> Soldering Iron - 30W (USE, 110V) TOL-09507 </p> <li> <p> <p> </p> <p> Hobby Knife TOL-09200 </p> <li> <p> <p> </p> <p>Chip Quik No-Clean Flux Pen - 10mL CAB-14579 </p>"},{"location":"introduction/#smart-watch-example-materials","title":"Smart Watch Example Materials","text":"<p>This guide also includes a demo using the Qwiic Pocket Development Board - ESP32-C6 with three Qwiic breakouts to create a DIY \"smart watch\" (sans the wristband) complete with display, pedometer, and motion controls. If you'd like to follow along and build this example, you'll need the following Qwiic breakouts:</p> <ul> <li>      ---     SparkFun Micro OLED Breakout (Qwiic)     LCD-14532     </li> <li>      ---     SparkFun Real Time Clock Module - RV-1805 (Qwiic)     BOB-14558     </li> <li>      ---     SparkFun Triple Axis Accelerometer Breakout - BMA400 (Qwiic)     SEN-21208     </li> </ul> <p>You'll also need three Qwiic cables of your choice of length and a set of standoffs to assemble the smart watch. We recommend either the 50mm or 100mm flexible cables as shown below:</p> <ul> <li>      ---     Flexible Qwiic Cable - 50mm     PRT-17260     </li> <li>      ---     Flexible Qwiic Cable - 100mm     PRT-17259     </li> <li>      ---     Standoff - Metal Hex (4-40; 3/8\"; 10 pack)     PRT-10463     </li> <li>      ---     Screw - Phillips Head (1/4\", 4-40, 10 pack)     PRT-10453     </li> <li>      ---     Nut - Metal (4-40, 10 pack)     PRT-10453      </li> </ul>"},{"location":"introduction/#suggested-reading","title":"Suggested Reading","text":"<p>We designed this board for integration into SparkFun's Qwiic connect system.  Click on the banner below to learn more about the SparkFun Qwiic Connect System.</p> Qwiic Connect System <p>Before getting started with this Hookup Guide, you may want to read through the tutorials below if you are not familiar with the concepts covered in them or want a refresher. If you are using either of the Qwiic Shields linked above, we recommend reading through their respective Hookup Guides before continuing with this tutorial:</p> <ul> <li> <p> Serial Communication </p> </li> <li> <p> I2C </p> </li> <li> <p> Logic Levels </p> </li> <li> <p> Installing Arduino IDE </p> </li> <li> <p> Installing an Arduino Library </p> </li> <li> <p> Serial Terminal Basics </p> </li> <li> <p> How to Work with Jumper Pads and PCB Traces </p> </li> </ul>"},{"location":"resources/","title":"Resources","text":"<p>Check out the resources below for more information about the Qwiic Pocket Development Board - ESP32-C6:</p> <ul> <li>Schematic</li> <li>Eagle Files</li> <li>Board Dimensions</li> <li>Fritzing Part</li> <li>Datasheet ESP32-C6-MINI-1</li> <li>Techincal Reference Manual ESP32-C6</li> </ul>"},{"location":"single_page/","title":"Introduction","text":"<ul> <li> <p> SparkFun Qwiic Pocket Development Board - ESP32-C6 SKU: DEV-22925 <p> </p> <p> </p> <li> <p>The SparkFun Qwiic Pocket Development Board - ESP32-C6features the ESP32-C6 Mini-1 module from espressif<sup>\u2122</sup>. The ESP32-C6 SoC is built around a RISC-V single-core processor with 4 MB flash memory and supports 2.4 GHz WiFi 6, Bluetooth<sup>\u00ae</sup> 5 (with Low Energy), Zigbee and Thread 802.15.4 wireless protocols. The module uses an integrated PCB antenna.      The ESP32-C6 includes on-chip serial-to-UART conversion which helps reduce the number of components on the development board so we designed this Qwiic Dev Board to cram as much as we could into the Qwiic system's 1\"x1\" form factor. It also includes a USB-C connector, 2-pin JST connector for a single-cell LiPo battery along with a charging circuit for a connected battery, a Qwiic connector, and it also breaks out eight GPIO pins (including one UART). </p> <p> Purchase from SparkFun  </p> </li>"},{"location":"single_page/#required-materials","title":"Required Materials","text":"<p>To follow along with this guide you will need a USB-C cable to connect the dev board to your computer: </p> <ul> <li> <p> <p> </p> <p> USB 3.1 Cable A to C - 3 Foot CAB-14743 </p> <li> <p> <p> </p> <p> Reversible USB A to C Cable - 2m CAB-15424 </p> <p>You may also want to get a Qwiic cable or kit to connect the Qwiic Dev Board - ESP32-C6 to other Qwiic devices:</p> <ul> <li> <p> <p> </p> <p> Flexible Qwiic Cable - 100mm PRT-17259 </p> <li> <p> <p> </p> <p> Flexible Qwiic Cable - 50mm PRT-17260 </p> <li> <p> <p> </p> <p> Flexible Qwiic Cable - 500mm PRT-17257 </p> <li> <p> <p> </p> <p>Flexible Qwiic Cable - Female Jumper (4-pin) CAB-17261 </p>"},{"location":"single_page/#optional-materials","title":"Optional Materials","text":"<p>The Qwiic Dev Board - ESP32-C6 includes a 2-pin JST connector and integrated charging circuit for an attached single-cell LiPo battery. Below are a few options for batteries we recommend for battery-powered applications:</p> <ul> <li> <p> <p> </p> <p> Lithium Ion Battery - 1250mAh (IEC62133 Certified) PRT-18286 </p> <li> <p> <p> </p> <p> Lithium Ion Battery - 2Ah PRT-13855 </p> <li> <p> <p> </p> <p> Lithium Ion Battery - 400mAh PRT-13851 </p> <li> <p> <p> </p> <p> Lithium Ion Battery - 850mAh PRT-13854 </p> <p>If you prefer a soldered connection or want to modify the solder jumpers on this board, you may need some of the products listed below:</p> <ul> <li> <p> <p> </p> <p> Break Away Headers - Straight PRT-00116 </p> <li> <p> <p> </p> <p> Soldering Iron - 30W (USE, 110V) TOL-09507 </p> <li> <p> <p> </p> <p> Hobby Knife TOL-09200 </p> <li> <p> <p> </p> <p>Chip Quik No-Clean Flux Pen - 10mL CAB-14579 </p>"},{"location":"single_page/#smart-watch-example-materials","title":"Smart Watch Example Materials","text":"<p>This guide also includes a demo using the Qwiic Pocket Development Board - ESP32-C6 with three Qwiic breakouts to create a DIY \"smart watch\" (sans the wristband) complete with display, pedometer, and motion controls. If you'd like to follow along and build this example, you'll need the following Qwiic breakouts:</p> <ul> <li>      ---     SparkFun Micro OLED Breakout (Qwiic)     LCD-14532     </li> <li>      ---     SparkFun Real Time Clock Module - RV-1805 (Qwiic)     BOB-14558     </li> <li>      ---     SparkFun Triple Axis Accelerometer Breakout - BMA400 (Qwiic)     SEN-21208     </li> </ul> <p>You'll also need three Qwiic cables of your choice of length and a set of standoffs to assemble the smart watch. We recommend either the 50mm or 100mm flexible cables as shown below:</p> <ul> <li>      ---     Flexible Qwiic Cable - 50mm     PRT-17260     </li> <li>      ---     Flexible Qwiic Cable - 100mm     PRT-17259     </li> <li>      ---     Standoff - Metal Hex (4-40; 3/8\"; 10 pack)     PRT-10463     </li> <li>      ---     Screw - Phillips Head (1/4\", 4-40, 10 pack)     PRT-10453     </li> <li>      ---     Nut - Metal (4-40, 10 pack)     PRT-10453      </li> </ul>"},{"location":"single_page/#suggested-reading","title":"Suggested Reading","text":"<p>We designed this board for integration into SparkFun's Qwiic connect system.  Click on the banner below to learn more about the SparkFun Qwiic Connect System.</p> Qwiic Connect System <p>Before getting started with this Hookup Guide, you may want to read through the tutorials below if you are not familiar with the concepts covered in them or want a refresher. If you are using either of the Qwiic Shields linked above, we recommend reading through their respective Hookup Guides before continuing with this tutorial:</p> <ul> <li> <p> Serial Communication </p> </li> <li> <p> I2C </p> </li> <li> <p> Logic Levels </p> </li> <li> <p> Installing Arduino IDE </p> </li> <li> <p> Installing an Arduino Library </p> </li> <li> <p> Serial Terminal Basics </p> </li> <li> <p> How to Work with Jumper Pads and PCB Traces </p> </li> </ul>"},{"location":"single_page/#hardware-overview","title":"Hardware Overview","text":"<p>Let's take a closer look at the ESP32-C6 module and other hardware on the Qwiic Pocket Development Board.</p>"},{"location":"single_page/#esp32-c6-mini-1-module","title":"ESP32-C6 Mini-1 Module","text":"<p>The ESP32-C6 Mini-1 module from espressif features a 32-bit RISC-V single-core processor with an integrated wireless stack. The wireless stack is compatible with 2.4 GHz WiFi 6, Bluetooth<sup>\u00ae</sup> 5.3, Zigbee and Thread (802.15.4) and uses an on-board PCB antenna.</p> <p></p> <p>This development board uses the Mini version of the C6 module which has slightly less computing power in exchange for greater power efficiency. This makes this module perfect for battery-powered applications. The module features a wide range of peripheral options including SPI, UART, LPUART, I<sup>2</sup>C, I<sup>2</sup>S, LED PWM, USB Serial/JTAG controller, ADC and more. Many of these peripherals can be mapped to any GPIO pin though some are tied to specific pins. Refer to the datasheet for a complete overview of the ESP32-C6-MINI-1.</p> <p>The ESP32-C6 has 4 MB Flash memory along with 512 KB SRAM (high power)/ 16 KB SRAM (low power). The module uses pin strapping to configure boot mode parameters. The board defaults to standard mode (GPIO 9 internal pull-up, all other strapping pins floating) but it can be set to other parameters by performing the following pin strapping:</p> <ul> <li>SDIO Sampling and Driving Clock Edge - MTMS &amp; MTDI</li> <li>Chip Boot Mode - GPIO8 &amp; GPIO9</li> <li>ROM Code Printing to UART - GPIO8</li> <li>JTAG Signal Source - GPIO15</li> </ul>"},{"location":"single_page/#power-components","title":"Power Components","text":""},{"location":"single_page/#usb-c-connector","title":"USB-C Connector","text":"<p>The USB-C connector on the board acts as the primary serial interface for the ESP32-C6 module as well as a power input. It connects directly to the ESP32-C6's USB serial converter. The 5V USB input voltage is regulated down to 3.3V through a voltage regulator with a max current of 500mA@3.3V.</p> <p></p>"},{"location":"single_page/#jst-connector-battery-charger","title":"JST Connector &amp; Battery Charger","text":"<p>The board has a 2-pin JST connector to connect a single-cell Lithium Ion (LiPo) battery for battery-powered applications. It also has an MCP73831 battery charger to charge an attached battery. The charge rate is set to 214mA@3.3V. The MCP73831 receives power from the V_USB line so it only is powered when 5V is provided either over USB or the V_USB PTH pin. If applying voltage directly to the V_USB pin make sure it does not exceed 5.5V.</p> <p></p>"},{"location":"single_page/#pinout-qwiic-connector","title":"Pinout &amp; Qwiic Connector","text":""},{"location":"single_page/#pth-pins","title":"PTH Pins","text":"<p>The Qwiic Dev Board routes eight GPIO pins to a pair of 0.1\"-spaced PTH headers. One side has 3.3V and GND pins along with I/O pins 2, 3, 4, and 5. The other side has through-holes for V_USB and VBatt as well as I/O pins 16 (TX), 17 (RX), 18, and 19.</p> <p></p>"},{"location":"single_page/#qwiic-connector","title":"Qwiic Connector","text":"<p>There's a Qwiic connector on the board tied to the ESP32-C6's Low Power I<sup>2</sup>C bus (I/O pins 6 and 7) for easy integration into SparkFun's Qwiic ecosystem. The Qwiic connector provides connections for SDA, SCL, 3.3V, and Ground.</p> <p></p>"},{"location":"single_page/#buttons","title":"Buttons","text":"<p>There are two buttons on the board labeled RESET and BOOT. The RESET button is tied to the ESP32-C6's Enable (EN) pin and resets the module when pressed. The BOOT button puts the ESP32-C6 into bootloader mode when held down during power on or reset.</p> <p></p>"},{"location":"single_page/#leds","title":"LEDs","text":"<p>The board has three LEDs labeled PWR, STAT, and CHG. The red Power (PWR) LED indicates whenever the 3.3V circuit is powered. The blue Status (STAT) LED is tied to IO23 on the ESP32. The yellow Charge (CHG) LED indicates whenever the MCP73831 is charging a connected LiPo battery.</p> <p></p>"},{"location":"single_page/#solder-jumpers","title":"Solder Jumpers","text":"<p>There are four solder jumpers on the Qwiic Dev Board labeled CHG, I<sup>2</sup>C, SHLD, and PWR. The table below outlines the jumpers' labels, default state, function, and any notes regarding their use:</p> <p></p> Label Default State Function Notes CHG CLOSED Completes Charge LED circuit Open to disable Charge LED I<sup>2</sup>C CLOSED Pulls the SDA/SCL lines to 3.3V through a pair of 2.2k\u03a9 resistors Three-way jumper. Open completely to disable pullups SHLD CLOSED Ties the USB-C shield pin to the ground plane Open to isolate USB-C shield pin from the board's ground plane PWR CLOSED Completes the Power LED circuit Open to disable the Power LED"},{"location":"single_page/#board-dimensions","title":"Board Dimensions","text":"<p>The Qwiic Dev Board - ESP32-C6 matches the 1\" x 1\" (22.6mm x 22.6mm) Qwiic form factor and has two mounting holes that fit a 4-40 screw. </p> <p></p>"},{"location":"single_page/#hardware-assembly","title":"Hardware Assembly","text":""},{"location":"single_page/#basic-usb-assembly","title":"Basic USB Assembly","text":"<p>Basic assembly of the Qwiic Pocket Development Board only requires a USB-C cable connecting the board to a computer. Just plug the cable into the USB-C connector like the photo below shows and move on to the Software Setup section. </p> <p></p> <p>Note</p> <p>Your computer may not recognize the board as a known USB device if you have not installed the espressif boards package in Arduino and/or installed the espressif IDF.</p>"},{"location":"single_page/#battery-assembly","title":"Battery Assembly","text":"<p>If you prefer a battery-powered application, plug a single-cell LiPo battery into the 2-pin JST connector on the underside of the board like the photo below. Remember, the MCP73831 only charges the battery when V_USB has voltage present either from the USB-C connector or through the V_USB PTH pin.</p> <p></p> <p>For tips on the proper use of a LiPo battery and the 2-pin JST connector, please read through our Single Cell LiPo Battery Care tutorial.</p>"},{"location":"single_page/#software-setup","title":"Software Setup","text":"<p>Attention</p> <p>If this is your first time using Arduino, please read through our tutorial on installing the Arduino IDE. If you have not installed an Arduino library before, we recommend you check out our installation guide.</p> <p>With the Qwiic Pocket Dev Board connected to our computer, it's time to set up the boards package in Arduino.</p>"},{"location":"single_page/#installing-espressif-arduino-boards","title":"Installing espressif Arduino Boards","text":"<p>The espressif ESP32 Arduino Boards package includes the Qwiic Pocket Development Board - ESP32-C6. Install it by opening the Boards Manager tab on the left side of the IDE, then search for \"espressif ESP32\" and install the latest version of the ESP32 boards package as the screenshot below shows. This assumes the use of Arduino 2.x and later. If you're on Legacy Arduino (1.8x and previous) can find the Boards Manager tool in File/Tools/Boards Manager.</p> <p></p>"},{"location":"single_page/#espressif-idf","title":"espressif IDF","text":"<p>Users who prefer to use espressif's development toolkit, espressif IDF, can get started by following their instructions here and  ESP32-C6 specific documentation here. </p>"},{"location":"single_page/#arduino-examples","title":"Arduino Examples","text":"<p>Now that we've installed the espressif boards package in Arduino, it's time to upload our first sketch to make sure everything is working properly.</p>"},{"location":"single_page/#example-1-blink","title":"Example 1 - Blink","text":"<p>This basic example makes sure the board package installed correctly and the board accepts programming properly to blink the blue STAT LED on the board every second. Open the example in Arduino by navigating to File &gt; Examples &gt; Basics &gt; 01-Blink.</p> <p>USB CDC On Boot Settings</p> <p>Take note of the option labeled \"USB CDC on Boot\" when selecting the Board from the Tools menu. This option sets the serial outputs and defines their label for use in code. The SparkFun variants default to Enable USB CDC on boot which sets both <code>Serial</code> and <code>Serial0</code> as available serial ports. In this configuration, <code>Serial</code> corresponds to the direct USB/Serial converter on the chip (and the USB-C interface) and <code>Serial0</code> corresponds to the UART0 bus (default pins are 16 and 17).</p> <p>With either setting, <code>Serial1</code> is available and refers to the UART1 bus (default pins are 4 and 5).</p> <p>Select the board (SparkFun ESP32-C6 Qwiic Pocket) and Port and click \"Upload\". After uploading you should see the STAT LED on the board blinking every second.</p>"},{"location":"single_page/#smart-watch-assembly","title":"Smart Watch Assembly","text":"<p>Building the smart watch with the Pocket Development Board and the three Qwiic breakouts requires a few assembly steps to build the smart watch stack and connect everything using standofs, screws, hookup wire, and Qwiic cables. This assembly also requires a bit of through-hole soldering so if you've never soldered before or would like a refresher, take a look at our How to Solder: Through-Hole Soldering tutorial.</p> <p>Note</p> <p>Some users may want to skip ahead and program the Qwiic Pocket Development Board before assembling the smart watch. If you are one of these people, skip ahead to the Software Setup and Smart Watch Example sections to upload the code before building your smart watch stack.</p> <p>Start by soldering a short length of wire (roughly one inch) to pin 4 on the Pocket Dev Board and then solder the other end to INT1 on the BMA400 Breakout:</p> <p></p> <p>Next, stack the BMA400 Breakout on top of the Qwiic Pocket Dev Board using two standoffs and two nuts to secure them to the Qwiic Pocket Dev Board; then connect the two with a Qwiic cable like the photo below show: </p> <p></p> <p>Now stack the RTC Breakout on top of those two with a Qwiic cable between the BMA400 and RTC breakouts and finally add the Qwiic OLED on top with a Qwiic cable between this and the RTC breakout. You may want to connect the Qwiic cable to the OLED before securing it into place depending on which connector you opt for as one is a bit of a tough reach once the board is attached. Secure everything in place while being careful not to damage any of the components since the standoffs and other hardware come very close to them. </p> <p>With the boards stacked and connected together you can plug the battery in at this point, but can also wait until after programming the Pocket Development Board as well. The final assembly should look like the photo below:</p> <p></p>"},{"location":"single_page/#smart-watch-example","title":"Smart Watch Example","text":""},{"location":"single_page/#smart-watch-example-libraries","title":"Smart Watch Example Libraries","text":"<p>The smart watch demo requires three Arduino libraries for the three Qwiic breakouts used in it. Install the libraries through Arduino's Library Manager Tool by searching for the following: \"Micro OLED Breakout\", \"SparkFun Qwiic RTC RV1805\", and \"SparkFun BMA400\". Users who prefer to install them manually can download ZIP folders of the libraries by clicking the buttons below:</p> <p> SparkFun Micro OLED Arduino Library (ZIP) </p> <p> SparkFun RV-1805 Arduino Library (ZIP) </p> <p> SparkFun BMA400 Arduino Library (ZIP) </p>"},{"location":"single_page/#upload-demo-code","title":"Upload Demo Code","text":"<p>With the Qwiic Pocket Dev Board smart watch assembled, board definitions and libraries installed, we can upload the smart watch code to the Qwiic Pocket Development board. Copy the code below into a blank sketch or you can download it from the GitHub repository.</p> Smart Watch Demo <pre><code>// Inlcude libraries needed\n#include &lt;Wire.h&gt;\n#include \"SparkFun_BMA400_Arduino_Library.h\"\n#include &lt;SparkFun_Qwiic_OLED.h&gt;\n#include &lt;SparkFun_RV1805.h&gt;\n#include &lt;WiFi.h&gt;\n#include \"time.h\"\n\n// WiFi SSID and password, change these for your WiFi network!\nconst char* ssid = \"your-ssid\";\nconst char* password = \"your-password\";\n\n// Create RTC object\nRV1805 rtc;\n\n// Create OLED object\nQwiicMicroOLED oled;\n\n// Create sensor object\nBMA400 accelerometer;\n\n// Pin used for button input\nint buttonPin = 9;\n\n// Pin used for measuring battery voltage\nint batteryPin = 1;\n\n// Pin used for interrupt detection\nint interruptPin = 4;\n\n// Flag to know when interrupts occur\nvolatile bool interruptOccurred = false;\n\n// Flag to know when user input is requested\nbool userInput = true;\n\n// Screen index\nuint8_t screenIndex = 0;\n\n// Enum to define various screen indices\ntypedef enum\n{\n    SCREEN_CLOCK,\n    SCREEN_STEP_COUNTER,\n    SCREEN_BATTERY_VOLTAGE,\n    SCREEN_SYNC_RTC,\n    SCREEN_MAX\n} screen_index_t;\n\n// Screen size properties\nuint8_t midX = 0;\nuint8_t midY = 0;\nuint8_t clockRadius = 0;\nuint8_t rowHeight = 0;\n\n// Screen display flags\nvolatile bool updateScreen = true;\nvolatile bool screenOn = true;\n\n// Screen update timer\nuint32_t lastUpdateTime = 0;\nuint32_t updateInterval = 1000/25;\n\n// Sleep timer to automatically enter deep sleep after inactivity\nuint32_t sleepTimerStart = 0;\nuint32_t sleepTimerPeriod = 60000;\n\n// Standard time zone relative to GMT (not daylight savings!)\nint8_t timeZone = -7;\n\nvoid setup()\n{\n    // Start serial\n    Serial.begin(115200);\n    Serial.println(\"Watch demo begin!\");\n\n    // Configure button pin as input with pullup\n    pinMode(buttonPin, INPUT_PULLUP);\n\n    // Configure battery pin as input\n    pinMode(batteryPin, INPUT);\n\n    // The ESP32-C6 has an attenuator on the ADC, which defaults to 11dB. This causes the resolution to be reduced\n    analogSetAttenuation(ADC_0db);\n\n    // Begin I2C driver\n    Wire.begin(6, 7);\n\n    // Begin RTC\n    while(!rtc.begin())\n    {\n        Serial.println(\"Error: RTC not connected, check wiring and I2C address!\");\n        delay(1000);\n    }\n    Serial.println(\"RTC connected!\");\n\n    // Manually set time (uncomment if needed, set current time and upload, then comment out and upload again)\n    // rtc.setTime(0,second,minute,hour,day,month,year,weekday);\n\n    // Begin OLED\n    while(!oled.begin())\n    {\n        Serial.println(\"Error: OLED not connected, check wiring and I2C address!\");\n        delay(1000);\n    }\n    Serial.println(\"OLED connected!\");\n\n    // Set screen size parameters\n    midX = oled.getWidth() / 2;\n    midY = oled.getHeight() / 2;\n    clockRadius = min(midX, midY) - 2;\n    rowHeight = oled.getHeight() / 3;\n\n    // Begin accelerometer\n    while(accelerometer.beginI2C() != BMA400_OK)\n    {\n        Serial.println(\"Error: BMA400 not connected, check wiring and I2C address!\");\n        delay(1000);\n    }\n    Serial.println(\"BMA400 connected!\");\n\n    // Set up tap detection\n    bma400_tap_conf tapConfig =\n    {\n        .axes_sel = BMA400_TAP_Z_AXIS_EN, // Which axes to evaluate for interrupts (X/Y/Z in any combination)\n        .sensitivity = BMA400_TAP_SENSITIVITY_7, // Sensitivity threshold, up to 7 (lower is more sensitive)\n        .tics_th = BMA400_TICS_TH_6_DATA_SAMPLES, // Max time between top/bottom peaks of a single tap\n        .quiet = BMA400_QUIET_60_DATA_SAMPLES, // Minimum time between taps to trigger interrupt\n        .quiet_dt = BMA400_QUIET_DT_4_DATA_SAMPLES, // Minimum time between 2 taps to trigger double tap interrupt\n        .int_chan = BMA400_INT_CHANNEL_1 // Which pin to use for interrupts\n    };\n    accelerometer.setTapInterrupt(&amp;tapConfig);\n\n    // Set up generic 1 interrupt, used to detect when device is rotated away from user\n    bma400_gen_int_conf genConfig =\n    {\n        .gen_int_thres = 125, // 8mg resolution (eg. gen_int_thres=5 results in 40mg)\n        .gen_int_dur = 100, // 10ms resolution (eg. gen_int_dur=5 results in 50ms)\n        .axes_sel = BMA400_AXIS_XYZ_EN, // Which axes to evaluate for interrupts (X/Y/Z in any combination)\n        .data_src = BMA400_DATA_SRC_ACCEL_FILT_LP, // Which filter to use (must be 100Hz, datasheet recommends filter 2)\n        .criterion_sel = BMA400_ACTIVITY_INT, // Trigger interrupts when active or inactive\n        .evaluate_axes = BMA400_ANY_AXES_INT, // Logical combining of axes for interrupt condition (OR/AND)\n        .ref_update = BMA400_UPDATE_MANUAL, // Whether to automatically update reference values\n        .hysteresis = BMA400_HYST_96_MG, // Hysteresis acceleration for noise rejection\n        .int_thres_ref_x = (uint16_t) -360, // Raw 12-bit acceleration value\n        .int_thres_ref_y = 0, // Raw 12-bit acceleration value\n        .int_thres_ref_z = 360, // Raw 12-bit acceleration value (at 4g range (default), 512 = 1g)\n        .int_chan = BMA400_INT_CHANNEL_1 // Which pin to use for interrupts\n    };\n    accelerometer.setGeneric1Interrupt(&amp;genConfig);\n\n    // Set up generic 2 interrupt, used to detect when device is rotated towards user\n    genConfig.gen_int_thres = 50;\n    genConfig.gen_int_dur = 50;\n    genConfig.criterion_sel = BMA400_INACTIVITY_INT;\n    genConfig.evaluate_axes = BMA400_ALL_AXES_INT;\n    accelerometer.setGeneric2Interrupt(&amp;genConfig);\n\n    // Enable step counting\n    bma400_step_int_conf stepConfig = {.int_chan = BMA400_INT_CHANNEL_1};\n    accelerometer.setStepCounterInterrupt(&amp;stepConfig);\n\n    // Set INT 1 pin as push pull active high\n    accelerometer.setInterruptPinMode(BMA400_INT_CHANNEL_1, BMA400_INT_PUSH_PULL_ACTIVE_1);\n\n    // Enable interrupts from accelerometer\n    accelerometer.enableInterrupt(BMA400_STEP_COUNTER_INT_EN, true);\n    accelerometer.enableInterrupt(BMA400_SINGLE_TAP_INT_EN, true);\n    accelerometer.enableInterrupt(BMA400_DOUBLE_TAP_INT_EN, true);\n    accelerometer.enableInterrupt(BMA400_GEN1_INT_EN, true);\n    accelerometer.enableInterrupt(BMA400_GEN2_INT_EN, true);\n    accelerometer.enableInterrupt(BMA400_LATCH_INT_EN, true);\n\n    // Attach interrupt handler\n    pinMode(interruptPin, INPUT);\n    attachInterrupt(digitalPinToInterrupt(interruptPin), bma400InterruptHandler, RISING);\n\n    // Reset sleep timer\n    sleepTimerStart = millis();\n}\n\nvoid loop()\n{\n    // Check if we need to enter deep sleep\n    if((digitalRead(buttonPin) == LOW) || (millis() &gt; (sleepTimerStart + sleepTimerPeriod)))\n    {\n        enterDeepSleep();\n    }\n\n    // Check whether interrupt triggered from accelerometer\n    if(interruptOccurred)\n    {\n        // Reset interrupt flag\n        interruptOccurred = false;\n\n        // Reset sleep timer\n        sleepTimerStart = millis();\n\n        Serial.print(\"Interrupt occured: \");\n\n        // Check what the interrupt source was\n        uint16_t interruptStatus = 0;\n        accelerometer.getInterruptStatus(&amp;interruptStatus);\n        if(interruptStatus &amp; BMA400_ASSERTED_S_TAP_INT)\n        {\n            // Single tap, increment screen index if screen is on\n            if(screenOn)\n            {\n                Serial.println(\"Single tap\");\n                screenIndex++;\n                updateScreen = true;\n            }\n        }\n        else if(interruptStatus &amp; BMA400_ASSERTED_D_TAP_INT)\n        {\n            // Double tap used for input within a screen index, if applicable.\n            // This always follows a single tap, so decrement screen index and\n            // set input flag, if screen is on\n            if(screenOn)\n            {\n                Serial.println(\"Double tap\");\n                screenIndex--;\n                updateScreen = true;\n                userInput = true;\n            }\n        }\n        else if(interruptStatus &amp; BMA400_ASSERTED_GEN1_INT)\n        {\n            // Generic 1 indicates the device was rotated away from the user, in\n            // which case we'll turn the screen off\n            Serial.println(\"Generic 1\");\n            screenOn = false;\n            oled.erase();\n            oled.display();\n\n            // The generic interrupts trigger constantly. Disable generic 1, and\n            // enable generic 2\n            accelerometer.enableInterrupt(BMA400_GEN1_INT_EN, false);\n            accelerometer.enableInterrupt(BMA400_GEN2_INT_EN, true);\n        }\n        else if(interruptStatus &amp; BMA400_ASSERTED_GEN2_INT)\n        {\n            // Generic 2 indicates the device was rotated towards the user, in\n            // which case we'll turn the screen on\n            Serial.println(\"Generic 2\");\n            screenOn = true;\n            updateScreen = true;\n\n            // The generic interrupts trigger constantly. Disable generic 2, and\n            // enable generic 1\n            accelerometer.enableInterrupt(BMA400_GEN1_INT_EN, true);\n            accelerometer.enableInterrupt(BMA400_GEN2_INT_EN, false);\n        }\n        else if(interruptStatus &amp; BMA400_ASSERTED_STEP_INT)\n        {\n            // Step counter incremented, update the screen to give live count\n            Serial.println(\"Step\");\n            updateScreen = true;\n        }\n        else\n        {\n            // Unknown source, just print and ignore it\n            Serial.println(\"Unknown interrupt\");\n            Serial.println(interruptStatus, HEX);\n        }\n    }\n\n    // Figure out what to display on the screen, if anything\n    if(screenOn)\n    {\n        screenIndex %= SCREEN_MAX;\n        switch(screenIndex)\n        {\n            case SCREEN_CLOCK:\n                displayClock();\n                break;\n            case SCREEN_STEP_COUNTER:\n                displayStepCounter();\n                break;\n            case SCREEN_BATTERY_VOLTAGE:\n                displayBatteryVoltage();\n                break;\n            case SCREEN_SYNC_RTC:\n                displaySyncRTC();\n                break;\n            default:\n                // Shouldn't get here, but just in case\n                screenIndex = 0;\n                break;\n        }\n    }\n\n    // Reset flags\n    userInput = false;\n}\n\n// Displays time an analog clock style\nvoid displayClock()\n{\n    // Check if we need to update the screen. Uses a timer to limit refresh rate\n    if(!updateScreen)\n    {\n        if(millis() &gt;= (lastUpdateTime + updateInterval))\n        {\n            lastUpdateTime += updateInterval;\n        }\n        else\n        {\n            return;\n        }\n    }\n    updateScreen = false;\n\n    // Get current time from RTC\n    rtc.updateTime();\n    int timeMilli = millis() % 1000;\n    int timeSecs = rtc.getSeconds();\n    int timeMins = rtc.getMinutes();\n    int timeHours = rtc.getHours() % 12;\n\n    // Clear OLED\n    oled.erase();\n\n    // Draw circle to define clock face\n    oled.circle(midX, midY, clockRadius);\n\n    // Draw a solid circle to indicate 1 second intervals\n    int x = (clockRadius+1) * sin(timeMilli * 2*PI/1000);\n    int y = (clockRadius+1) *-cos(timeMilli * 2*PI/1000);\n    oled.circleFill(midX + x, midY + y, 2);\n\n    // Draw second hand\n    x = clockRadius * sin(timeSecs * 2*PI/60);\n    y = clockRadius *-cos(timeSecs * 2*PI/60);\n    oled.line(midX, midY, midX + x, midY + y);\n\n    // Draw minute hand\n    x = clockRadius*.75 * sin(timeMins * 2*PI/60);\n    y = clockRadius*.75 *-cos(timeMins * 2*PI/60);\n    oled.line(midX, midY, midX + x, midY + y);\n\n    // Draw hour hand\n    x = clockRadius*.5 * sin(timeHours * 2*PI/12);\n    y = clockRadius*.5 *-cos(timeHours * 2*PI/12);\n    oled.line(midX, midY, midX + x, midY + y);\n\n    // Display on the OLED\n    oled.display();\n}\n\n// Displays step count\nvoid displayStepCounter()\n{\n    // Check if screen needs to be updated\n    if(!updateScreen)\n        return;\n    updateScreen = false;\n\n    // Create text buffer\n    char displayStr[10] = {0};\n    uint8_t numChars = 0;\n\n    // Get step count and activity type from accelerometer\n    uint32_t stepCount = 0;\n    uint8_t activityType = 0;\n    accelerometer.getStepCount(&amp;stepCount, &amp;activityType);\n\n    // Clear screen\n    oled.erase();\n\n    // Print header\n    numChars = sprintf(displayStr, \"Steps\");\n    printRow(0, displayStr, numChars);\n\n    // Print number of steps\n    numChars = sprintf(displayStr, \"%li\", stepCount);\n    printRow(1, displayStr, numChars);\n\n    // Print activity type\n    switch(activityType)\n    {\n        case BMA400_RUN_ACT:\n            numChars = sprintf(displayStr, \"Running\");\n            break;\n        case BMA400_WALK_ACT:\n            numChars = sprintf(displayStr, \"Walking\");\n            break;\n        case BMA400_STILL_ACT:\n            numChars = sprintf(displayStr, \"Standing\");\n            break;\n        default:\n            numChars = sprintf(displayStr, \"Unknown\");\n            break;\n    }\n    printRow(2, displayStr, numChars);\n\n    // Display on OLED\n    oled.display();\n}\n\n// Displays battery voltage\nvoid displayBatteryVoltage()\n{\n    // Check if screen needs to be updated\n    if(!updateScreen)\n        return;\n    updateScreen = false;\n\n    // Create text buffer\n    char displayStr[10] = {0};\n    uint8_t numChars = 0;\n\n    // Clear screen\n    oled.erase();\n\n    // Print header\n    numChars = sprintf(displayStr, \"Battery\");\n    printRow(0, displayStr, numChars);\n    numChars = sprintf(displayStr, \"Voltage\");\n    printRow(1, displayStr, numChars);\n\n    // Measure battery voltage, averaged over several samples\n    uint8_t numSamples = 100;\n    uint32_t batteryRaw = 0;\n    for(uint8_t i = 0; i &lt; numSamples; i++)\n    {\n        batteryRaw += analogRead(batteryPin);\n    }\n    float voltage = 3.3 / 4095 * batteryRaw / numSamples;\n\n    // Measured voltage is less than true battery voltage, partly because of the\n    // voltage divider circuit, and partly because the ADC has a non-zero input\n    // current. This scaler was experimentally found to correct these effects,\n    // though the nominal value may differ between boards\n    voltage *= 1.688;\n\n    // Print battery voltage\n    numChars = sprintf(displayStr, \"%.3fV\", voltage);\n    printRow(2, displayStr, numChars);\n\n    // Display on OLED\n    oled.display();\n}\n\nvoid displaySyncRTC()\n{\n    // Check if screen needs to be updated\n    if(!updateScreen)\n        return;\n    updateScreen = false;\n\n    // Create text buffer\n    char displayStr[10] = {0};\n    uint8_t numChars = 0;\n\n    // Clear screen\n    oled.erase();\n\n    // Print RTC sync message\n    numChars = sprintf(displayStr, \"Sync RTC\");\n    printRow(0, displayStr, numChars);\n    numChars = sprintf(displayStr, \"with NTP?\");\n    printRow(1, displayStr, numChars);\n\n    // Display on OLED\n    oled.display();\n\n    // Check if user requested to synchronize RTC\n    if(userInput)\n    {\n        // Clear screen\n        oled.erase();\n\n        // Print RTC sync message\n        numChars = sprintf(displayStr, \"Syncing\");\n        printRow(0, displayStr, numChars);\n        numChars = sprintf(displayStr, \"RTC...\");\n        printRow(1, displayStr, numChars);\n\n        // Display on OLED\n        oled.display();\n\n        // Start connecting to WiFi network\n        WiFi.begin(ssid, password);\n        while(WiFi.status() != WL_CONNECTED)\n        {\n            Serial.println(\"Connecting to WiFi...\");\n            delay(1000);\n        }\n\n        // Sync with an NTP server\n        configTime(timeZone * 3600, 3600, \"pool.ntp.org\");\n\n        // Disconnect WiFi\n        WiFi.disconnect(true);\n        WiFi.mode(WIFI_OFF);\n\n        // Get updated time\n        struct tm timeinfo;\n        getLocalTime(&amp;timeinfo);\n\n        // Set RTC to current time\n        uint8_t time[TIME_ARRAY_LENGTH];\n        time[TIME_HUNDREDTHS] = rtc.DECtoBCD(millis());\n        time[TIME_SECONDS] = rtc.DECtoBCD(timeinfo.tm_sec);\n        time[TIME_MINUTES] = rtc.DECtoBCD(timeinfo.tm_min);\n        time[TIME_HOURS] = rtc.DECtoBCD(timeinfo.tm_hour);\n        time[TIME_DATE] = rtc.DECtoBCD(timeinfo.tm_mday);\n        time[TIME_MONTH] = rtc.DECtoBCD(timeinfo.tm_mon);\n        time[TIME_YEAR] = rtc.DECtoBCD(timeinfo.tm_year);\n        time[TIME_DAY] = rtc.DECtoBCD(timeinfo.tm_wday);\n        rtc.setTime(time, TIME_ARRAY_LENGTH);\n\n        // Clear screen\n        oled.erase();\n\n        // Print RTC sync message\n        numChars = sprintf(displayStr, \"RTC\");\n        printRow(0, displayStr, numChars);\n        numChars = sprintf(displayStr, \"Synced!\");\n        printRow(1, displayStr, numChars);\n\n        // Display on OLED\n        oled.display();\n    }\n}\n\n// Helper function to display text on rows 0-2\nvoid printRow(uint8_t row, char* text, uint8_t numChars)\n{\n    // Set cursor location so text is centered\n    oled.setCursor(midX - 5 * numChars / 2, rowHeight * row);\n\n    // Print text at cursor location\n    oled.print(text);\n}\n\n// Helper function to minimuze total current consumption and enter deep sleep\nvoid enterDeepSleep()\n{\n    // Turn off display\n    oled.erase();\n    oled.display();\n    oled.displayPower(false);\n\n    // Minimize current consumption of RTC\n    rtc.enableLowPower();\n    rtc.enableSleep();\n    rtc.writeRegister(RV1805_CTRL1, 0x77);\n\n    // Disable accelerometer interrupts, except double tap\n    accelerometer.enableInterrupt(BMA400_STEP_COUNTER_INT_EN, false);\n    accelerometer.enableInterrupt(BMA400_SINGLE_TAP_INT_EN, false);\n    // accelerometer.enableInterrupt(BMA400_DOUBLE_TAP_INT_EN, false);\n    accelerometer.enableInterrupt(BMA400_GEN1_INT_EN, false);\n    accelerometer.enableInterrupt(BMA400_GEN2_INT_EN, false);\n\n    // Could have had a new interrupt fire, read status to clear old interrupts\n    uint16_t interruptStatus = 0;\n    accelerometer.getInterruptStatus(&amp;interruptStatus);\n\n    // Set interrupt pin as wakeup source\n    esp_deep_sleep_enable_gpio_wakeup(BIT(interruptPin), ESP_GPIO_WAKEUP_GPIO_HIGH);\n\n    // Enter deep sleep. This never returns, instead the code restarts entirely\n    esp_deep_sleep_start();\n}\n\n// ISR for accelerometer interrupts\nvoid bma400InterruptHandler()\n{\n    // Set flag to be evaluated later\n    interruptOccurred = true;\n}\n</code></pre> <p>Now select the board (SparkFun ESP32-C6 Qwiic Pocket) and the Port and click the \"Upload\" button. Once the code finishes uploading, you should see a clock display on the Qwiic Micro OLED screen. </p>"},{"location":"single_page/#code-to-note","title":"Code to Note","text":"<p>The code has a few settings users should take note of to get the most out of the smart watch demo. Let's take a closer look.</p>"},{"location":"single_page/#bma400-settings","title":"BMA400 Settings","text":"<p>The code sets several thresholds on the BMA400 for tap/double-tap detection, step counting, and tilt-thresholds to fairly generous values to make all of the motion actions easy to trigger but some may find these to be too easily triggered. The code sets the BMA400's tap detection sensitivity to the max value (7) so if you want to make it less sensitive adjust this line:</p> <pre><code>.sensitivity = BMA400_TAP_SENSITIVITY_7,\n</code></pre>"},{"location":"single_page/#ntp-configuration","title":"NTP Configuration","text":"<p>Syncing the RTC to a NTP (Network Time Protocol) server requires an internet connection. The code has placeholders for these values so you'll need to enter your network credentials in the section of code shown below:</p> <pre><code>const char* ssid = \"your-ssid\";\nconst char* password = \"your-password\";\n</code></pre>"},{"location":"single_page/#smart-watch-actions","title":"Smart Watch Actions","text":"<p>The smart watch code includes a bunch of motion-triggered actions to change the OLED display so let's take a closer look at them to make sure we get the most out of our smart watch.</p>"},{"location":"single_page/#deep-sleep-wake-return","title":"Deep Sleep Wake &amp; Return","text":"<p>The code tells the circuit to enter deep sleep on two conditions: 60 seconds of inactivity or pressing the BOOT button on the bottom of the Qwiic Development Board. Double-tapping the watch wakes it from deep sleep and turns on the OLED to display the last screen viewed (default after upload is the analog clock).</p>"},{"location":"single_page/#tilt-functions","title":"Tilt Functions","text":"<p>The OLED display is off by default to help conserve battery power. It enables the display when you're \"checking your watch\" so try tilting it in \"towards\" you with the OLED screen upright (ribbon cable on the bottom) and the display should turn on like the photo below:</p> <p></p> <p>Tilt the screen \"away\" to turn the screen back off. Otherwise, screen should return to deep sleep after 60 seconds of inactivity (ie. no tilts or taps).</p>"},{"location":"single_page/#tap-menu-options","title":"Tap Menu Options","text":"<p>When the OLED is active you can tap on the screen (or just trigger a tap action for the BMA400 like setting the watch down or a similar action) to cycle through the four display options: Clock, Step Counter, Battery Voltage, and Sync with NTP Server.</p>"},{"location":"single_page/#analog-clock","title":"Analog Clock","text":"<p>This display is a simple analog clock interface without hour markings. It also features a nifty second counter signified by a dot travelling around the clock face.</p> <p></p>"},{"location":"single_page/#step-counter","title":"Step Counter","text":"<p>The smart watch code also takes advantage of the BMA400's built-in step counting feature. It displays steps counted as well as the current action: Standing, Walking, and Running.</p> <p></p>"},{"location":"single_page/#battery-voltage","title":"Battery Voltage","text":"<p>The third screen option shows the remaining battery voltage of a connected battery voltage to keep track of remaining charge on of an attached battery.</p> <p></p>"},{"location":"single_page/#sync-with-ntp-server","title":"Sync with NTP Server","text":"<p>The last display option lets you remotely sync the RTC with an NTP (assuming it has a WiFi connection) by double-tapping the display when \"Sync with NTP Server\" is displayed.</p> <p></p>"},{"location":"single_page/#troubleshooting","title":"Troubleshooting","text":""},{"location":"single_page/#usb-cdc-on-boot-settings","title":"USB CDC on Boot Settings","text":"<p>Take note of the option labeled \"USB CDC on Boot\" when selecting the Board from the Tools menu. This option sets the serial outputs and defines their label for use in code. The SparkFun variants default to Enable USB CDC on boot which sets both <code>Serial</code> and <code>Serial0</code> as available serial ports. In this configuration, <code>Serial</code> corresponds to the direct USB/Serial converter on the chip (and the USB-C interface) and <code>Serial0</code> corresponds to the UART0 bus (default pins are 16 and 17).</p> <p>With either setting, <code>Serial1</code> is available and refers to the UART1 bus (default pins are 4 and 5).</p>"},{"location":"single_page/#general-troubleshooting","title":"General Troubleshooting","text":"<p>Need Help?</p> <p>If you need technical assistance or more information on a product that is not working as you expected, we recommend heading over to the SparkFun Technical Assistance page for some initial troubleshooting.</p> <p> SparkFun Technical Assistance Page </p> <p>If you can't find what you need there, the SparkFun Forums is a great place to search product forums and ask questions.</p> <p>Account Registration Required</p> <p>If this is your first visit to our forum, you'll need to create a Forum Account to post questions.</p>"},{"location":"single_page/#resources","title":"Resources:","text":"<p>Check out the resources below for more information about the Qwiic Pocket Development Board - ESP32-C6:</p> <ul> <li>Schematic</li> <li>Eagle Files</li> <li>Board Dimensions</li> <li>Fritzing Part</li> <li>Datasheet ESP32-C6-MINI-1</li> <li>Techincal Reference Manual ESP32-C6</li> </ul>"},{"location":"smart_watch_assembly/","title":"Smart Watch Assembly","text":"<p>Building the smart watch with the Pocket Development Board and the three Qwiic breakouts requires a few assembly steps to build the smart watch stack and connect everything using standofs, screws, hookup wire, and Qwiic cables. This assembly also requires a bit of through-hole soldering so if you've never soldered before or would like a refresher, take a look at our How to Solder: Through-Hole Soldering tutorial.</p> <p>Note</p> <p>Some users may want to skip ahead and program the Qwiic Pocket Development Board before assembling the smart watch. If you are one of these people, skip ahead to the Software Setup and Smart Watch Example sections to upload the code before building your smart watch stack.</p> <p>Start by soldering a short length of wire (roughly one inch) to pin 4 on the Pocket Dev Board and then solder the other end to INT1 on the BMA400 Breakout:</p> <p></p> <p>Next, stack the BMA400 Breakout on top of the Qwiic Pocket Dev Board using two standoffs and two nuts to secure them to the Qwiic Pocket Dev Board; then connect the two with a Qwiic cable like the photo below show: </p> <p></p> <p>Now stack the RTC Breakout on top of those two with a Qwiic cable between the BMA400 and RTC breakouts and finally add the Qwiic OLED on top with a Qwiic cable between this and the RTC breakout. You may want to connect the Qwiic cable to the OLED before securing it into place depending on which connector you opt for as one is a bit of a tough reach once the board is attached. Secure everything in place while being careful not to damage any of the components since the standoffs and other hardware come very close to them. </p> <p>With the boards stacked and connected together you can plug the battery in at this point, but can also wait until after programming the Pocket Development Board as well. The final assembly should look like the photo below:</p> <p></p>"},{"location":"smart_watch_example/","title":"Smart Watch Example","text":""},{"location":"smart_watch_example/#smart-watch-example-libraries","title":"Smart Watch Example Libraries","text":"<p>The smart watch demo requires three Arduino libraries for the three Qwiic breakouts used in it. Install the libraries through Arduino's Library Manager Tool by searching for the following: \"Micro OLED Breakout\", \"SparkFun Qwiic RTC RV1805\", and \"SparkFun BMA400\". Users who prefer to install them manually can download ZIP folders of the libraries by clicking the buttons below:</p> <p> SparkFun Micro OLED Arduino Library (ZIP) </p> <p> SparkFun RV-1805 Arduino Library (ZIP) </p> <p> SparkFun BMA400 Arduino Library (ZIP) </p>"},{"location":"smart_watch_example/#upload-demo-code","title":"Upload Demo Code","text":"<p>With the Qwiic Pocket Dev Board smart watch assembled, board definitions and libraries installed, we can upload the smart watch code to the Qwiic Pocket Development board. Copy the code below into a blank sketch or you can download it from the GitHub repository.</p> Smart Watch Demo <pre><code>// Inlcude libraries needed\n#include &lt;Wire.h&gt;\n#include \"SparkFun_BMA400_Arduino_Library.h\"\n#include &lt;SparkFun_Qwiic_OLED.h&gt;\n#include &lt;SparkFun_RV1805.h&gt;\n#include &lt;WiFi.h&gt;\n#include \"time.h\"\n\n// WiFi SSID and password, change these for your WiFi network!\nconst char* ssid = \"your-ssid\";\nconst char* password = \"your-password\";\n\n// Create RTC object\nRV1805 rtc;\n\n// Create OLED object\nQwiicMicroOLED oled;\n\n// Create sensor object\nBMA400 accelerometer;\n\n// Pin used for button input\nint buttonPin = 9;\n\n// Pin used for measuring battery voltage\nint batteryPin = 1;\n\n// Pin used for interrupt detection\nint interruptPin = 4;\n\n// Flag to know when interrupts occur\nvolatile bool interruptOccurred = false;\n\n// Flag to know when user input is requested\nbool userInput = true;\n\n// Screen index\nuint8_t screenIndex = 0;\n\n// Enum to define various screen indices\ntypedef enum\n{\n    SCREEN_CLOCK,\n    SCREEN_STEP_COUNTER,\n    SCREEN_BATTERY_VOLTAGE,\n    SCREEN_SYNC_RTC,\n    SCREEN_MAX\n} screen_index_t;\n\n// Screen size properties\nuint8_t midX = 0;\nuint8_t midY = 0;\nuint8_t clockRadius = 0;\nuint8_t rowHeight = 0;\n\n// Screen display flags\nvolatile bool updateScreen = true;\nvolatile bool screenOn = true;\n\n// Screen update timer\nuint32_t lastUpdateTime = 0;\nuint32_t updateInterval = 1000/25;\n\n// Sleep timer to automatically enter deep sleep after inactivity\nuint32_t sleepTimerStart = 0;\nuint32_t sleepTimerPeriod = 60000;\n\n// Standard time zone relative to GMT (not daylight savings!)\nint8_t timeZone = -7;\n\nvoid setup()\n{\n    // Start serial\n    Serial.begin(115200);\n    Serial.println(\"Watch demo begin!\");\n\n    // Configure button pin as input with pullup\n    pinMode(buttonPin, INPUT_PULLUP);\n\n    // Configure battery pin as input\n    pinMode(batteryPin, INPUT);\n\n    // The ESP32-C6 has an attenuator on the ADC, which defaults to 11dB. This causes the resolution to be reduced\n    analogSetAttenuation(ADC_0db);\n\n    // Begin I2C driver\n    Wire.begin(6, 7);\n\n    // Begin RTC\n    while(!rtc.begin())\n    {\n        Serial.println(\"Error: RTC not connected, check wiring and I2C address!\");\n        delay(1000);\n    }\n    Serial.println(\"RTC connected!\");\n\n    // Manually set time (uncomment if needed, set current time and upload, then comment out and upload again)\n    // rtc.setTime(0,second,minute,hour,day,month,year,weekday);\n\n    // Begin OLED\n    while(!oled.begin())\n    {\n        Serial.println(\"Error: OLED not connected, check wiring and I2C address!\");\n        delay(1000);\n    }\n    Serial.println(\"OLED connected!\");\n\n    // Set screen size parameters\n    midX = oled.getWidth() / 2;\n    midY = oled.getHeight() / 2;\n    clockRadius = min(midX, midY) - 2;\n    rowHeight = oled.getHeight() / 3;\n\n    // Begin accelerometer\n    while(accelerometer.beginI2C() != BMA400_OK)\n    {\n        Serial.println(\"Error: BMA400 not connected, check wiring and I2C address!\");\n        delay(1000);\n    }\n    Serial.println(\"BMA400 connected!\");\n\n    // Set up tap detection\n    bma400_tap_conf tapConfig =\n    {\n        .axes_sel = BMA400_TAP_Z_AXIS_EN, // Which axes to evaluate for interrupts (X/Y/Z in any combination)\n        .sensitivity = BMA400_TAP_SENSITIVITY_7, // Sensitivity threshold, up to 7 (lower is more sensitive)\n        .tics_th = BMA400_TICS_TH_6_DATA_SAMPLES, // Max time between top/bottom peaks of a single tap\n        .quiet = BMA400_QUIET_60_DATA_SAMPLES, // Minimum time between taps to trigger interrupt\n        .quiet_dt = BMA400_QUIET_DT_4_DATA_SAMPLES, // Minimum time between 2 taps to trigger double tap interrupt\n        .int_chan = BMA400_INT_CHANNEL_1 // Which pin to use for interrupts\n    };\n    accelerometer.setTapInterrupt(&amp;tapConfig);\n\n    // Set up generic 1 interrupt, used to detect when device is rotated away from user\n    bma400_gen_int_conf genConfig =\n    {\n        .gen_int_thres = 125, // 8mg resolution (eg. gen_int_thres=5 results in 40mg)\n        .gen_int_dur = 100, // 10ms resolution (eg. gen_int_dur=5 results in 50ms)\n        .axes_sel = BMA400_AXIS_XYZ_EN, // Which axes to evaluate for interrupts (X/Y/Z in any combination)\n        .data_src = BMA400_DATA_SRC_ACCEL_FILT_LP, // Which filter to use (must be 100Hz, datasheet recommends filter 2)\n        .criterion_sel = BMA400_ACTIVITY_INT, // Trigger interrupts when active or inactive\n        .evaluate_axes = BMA400_ANY_AXES_INT, // Logical combining of axes for interrupt condition (OR/AND)\n        .ref_update = BMA400_UPDATE_MANUAL, // Whether to automatically update reference values\n        .hysteresis = BMA400_HYST_96_MG, // Hysteresis acceleration for noise rejection\n        .int_thres_ref_x = (uint16_t) -360, // Raw 12-bit acceleration value\n        .int_thres_ref_y = 0, // Raw 12-bit acceleration value\n        .int_thres_ref_z = 360, // Raw 12-bit acceleration value (at 4g range (default), 512 = 1g)\n        .int_chan = BMA400_INT_CHANNEL_1 // Which pin to use for interrupts\n    };\n    accelerometer.setGeneric1Interrupt(&amp;genConfig);\n\n    // Set up generic 2 interrupt, used to detect when device is rotated towards user\n    genConfig.gen_int_thres = 50;\n    genConfig.gen_int_dur = 50;\n    genConfig.criterion_sel = BMA400_INACTIVITY_INT;\n    genConfig.evaluate_axes = BMA400_ALL_AXES_INT;\n    accelerometer.setGeneric2Interrupt(&amp;genConfig);\n\n    // Enable step counting\n    bma400_step_int_conf stepConfig = {.int_chan = BMA400_INT_CHANNEL_1};\n    accelerometer.setStepCounterInterrupt(&amp;stepConfig);\n\n    // Set INT 1 pin as push pull active high\n    accelerometer.setInterruptPinMode(BMA400_INT_CHANNEL_1, BMA400_INT_PUSH_PULL_ACTIVE_1);\n\n    // Enable interrupts from accelerometer\n    accelerometer.enableInterrupt(BMA400_STEP_COUNTER_INT_EN, true);\n    accelerometer.enableInterrupt(BMA400_SINGLE_TAP_INT_EN, true);\n    accelerometer.enableInterrupt(BMA400_DOUBLE_TAP_INT_EN, true);\n    accelerometer.enableInterrupt(BMA400_GEN1_INT_EN, true);\n    accelerometer.enableInterrupt(BMA400_GEN2_INT_EN, true);\n    accelerometer.enableInterrupt(BMA400_LATCH_INT_EN, true);\n\n    // Attach interrupt handler\n    pinMode(interruptPin, INPUT);\n    attachInterrupt(digitalPinToInterrupt(interruptPin), bma400InterruptHandler, RISING);\n\n    // Reset sleep timer\n    sleepTimerStart = millis();\n}\n\nvoid loop()\n{\n    // Check if we need to enter deep sleep\n    if((digitalRead(buttonPin) == LOW) || (millis() &gt; (sleepTimerStart + sleepTimerPeriod)))\n    {\n        enterDeepSleep();\n    }\n\n    // Check whether interrupt triggered from accelerometer\n    if(interruptOccurred)\n    {\n        // Reset interrupt flag\n        interruptOccurred = false;\n\n        // Reset sleep timer\n        sleepTimerStart = millis();\n\n        Serial.print(\"Interrupt occured: \");\n\n        // Check what the interrupt source was\n        uint16_t interruptStatus = 0;\n        accelerometer.getInterruptStatus(&amp;interruptStatus);\n        if(interruptStatus &amp; BMA400_ASSERTED_S_TAP_INT)\n        {\n            // Single tap, increment screen index if screen is on\n            if(screenOn)\n            {\n                Serial.println(\"Single tap\");\n                screenIndex++;\n                updateScreen = true;\n            }\n        }\n        else if(interruptStatus &amp; BMA400_ASSERTED_D_TAP_INT)\n        {\n            // Double tap used for input within a screen index, if applicable.\n            // This always follows a single tap, so decrement screen index and\n            // set input flag, if screen is on\n            if(screenOn)\n            {\n                Serial.println(\"Double tap\");\n                screenIndex--;\n                updateScreen = true;\n                userInput = true;\n            }\n        }\n        else if(interruptStatus &amp; BMA400_ASSERTED_GEN1_INT)\n        {\n            // Generic 1 indicates the device was rotated away from the user, in\n            // which case we'll turn the screen off\n            Serial.println(\"Generic 1\");\n            screenOn = false;\n            oled.erase();\n            oled.display();\n\n            // The generic interrupts trigger constantly. Disable generic 1, and\n            // enable generic 2\n            accelerometer.enableInterrupt(BMA400_GEN1_INT_EN, false);\n            accelerometer.enableInterrupt(BMA400_GEN2_INT_EN, true);\n        }\n        else if(interruptStatus &amp; BMA400_ASSERTED_GEN2_INT)\n        {\n            // Generic 2 indicates the device was rotated towards the user, in\n            // which case we'll turn the screen on\n            Serial.println(\"Generic 2\");\n            screenOn = true;\n            updateScreen = true;\n\n            // The generic interrupts trigger constantly. Disable generic 2, and\n            // enable generic 1\n            accelerometer.enableInterrupt(BMA400_GEN1_INT_EN, true);\n            accelerometer.enableInterrupt(BMA400_GEN2_INT_EN, false);\n        }\n        else if(interruptStatus &amp; BMA400_ASSERTED_STEP_INT)\n        {\n            // Step counter incremented, update the screen to give live count\n            Serial.println(\"Step\");\n            updateScreen = true;\n        }\n        else\n        {\n            // Unknown source, just print and ignore it\n            Serial.println(\"Unknown interrupt\");\n            Serial.println(interruptStatus, HEX);\n        }\n    }\n\n    // Figure out what to display on the screen, if anything\n    if(screenOn)\n    {\n        screenIndex %= SCREEN_MAX;\n        switch(screenIndex)\n        {\n            case SCREEN_CLOCK:\n                displayClock();\n                break;\n            case SCREEN_STEP_COUNTER:\n                displayStepCounter();\n                break;\n            case SCREEN_BATTERY_VOLTAGE:\n                displayBatteryVoltage();\n                break;\n            case SCREEN_SYNC_RTC:\n                displaySyncRTC();\n                break;\n            default:\n                // Shouldn't get here, but just in case\n                screenIndex = 0;\n                break;\n        }\n    }\n\n    // Reset flags\n    userInput = false;\n}\n\n// Displays time an analog clock style\nvoid displayClock()\n{\n    // Check if we need to update the screen. Uses a timer to limit refresh rate\n    if(!updateScreen)\n    {\n        if(millis() &gt;= (lastUpdateTime + updateInterval))\n        {\n            lastUpdateTime += updateInterval;\n        }\n        else\n        {\n            return;\n        }\n    }\n    updateScreen = false;\n\n    // Get current time from RTC\n    rtc.updateTime();\n    int timeMilli = millis() % 1000;\n    int timeSecs = rtc.getSeconds();\n    int timeMins = rtc.getMinutes();\n    int timeHours = rtc.getHours() % 12;\n\n    // Clear OLED\n    oled.erase();\n\n    // Draw circle to define clock face\n    oled.circle(midX, midY, clockRadius);\n\n    // Draw a solid circle to indicate 1 second intervals\n    int x = (clockRadius+1) * sin(timeMilli * 2*PI/1000);\n    int y = (clockRadius+1) *-cos(timeMilli * 2*PI/1000);\n    oled.circleFill(midX + x, midY + y, 2);\n\n    // Draw second hand\n    x = clockRadius * sin(timeSecs * 2*PI/60);\n    y = clockRadius *-cos(timeSecs * 2*PI/60);\n    oled.line(midX, midY, midX + x, midY + y);\n\n    // Draw minute hand\n    x = clockRadius*.75 * sin(timeMins * 2*PI/60);\n    y = clockRadius*.75 *-cos(timeMins * 2*PI/60);\n    oled.line(midX, midY, midX + x, midY + y);\n\n    // Draw hour hand\n    x = clockRadius*.5 * sin(timeHours * 2*PI/12);\n    y = clockRadius*.5 *-cos(timeHours * 2*PI/12);\n    oled.line(midX, midY, midX + x, midY + y);\n\n    // Display on the OLED\n    oled.display();\n}\n\n// Displays step count\nvoid displayStepCounter()\n{\n    // Check if screen needs to be updated\n    if(!updateScreen)\n        return;\n    updateScreen = false;\n\n    // Create text buffer\n    char displayStr[10] = {0};\n    uint8_t numChars = 0;\n\n    // Get step count and activity type from accelerometer\n    uint32_t stepCount = 0;\n    uint8_t activityType = 0;\n    accelerometer.getStepCount(&amp;stepCount, &amp;activityType);\n\n    // Clear screen\n    oled.erase();\n\n    // Print header\n    numChars = sprintf(displayStr, \"Steps\");\n    printRow(0, displayStr, numChars);\n\n    // Print number of steps\n    numChars = sprintf(displayStr, \"%li\", stepCount);\n    printRow(1, displayStr, numChars);\n\n    // Print activity type\n    switch(activityType)\n    {\n        case BMA400_RUN_ACT:\n            numChars = sprintf(displayStr, \"Running\");\n            break;\n        case BMA400_WALK_ACT:\n            numChars = sprintf(displayStr, \"Walking\");\n            break;\n        case BMA400_STILL_ACT:\n            numChars = sprintf(displayStr, \"Standing\");\n            break;\n        default:\n            numChars = sprintf(displayStr, \"Unknown\");\n            break;\n    }\n    printRow(2, displayStr, numChars);\n\n    // Display on OLED\n    oled.display();\n}\n\n// Displays battery voltage\nvoid displayBatteryVoltage()\n{\n    // Check if screen needs to be updated\n    if(!updateScreen)\n        return;\n    updateScreen = false;\n\n    // Create text buffer\n    char displayStr[10] = {0};\n    uint8_t numChars = 0;\n\n    // Clear screen\n    oled.erase();\n\n    // Print header\n    numChars = sprintf(displayStr, \"Battery\");\n    printRow(0, displayStr, numChars);\n    numChars = sprintf(displayStr, \"Voltage\");\n    printRow(1, displayStr, numChars);\n\n    // Measure battery voltage, averaged over several samples\n    uint8_t numSamples = 100;\n    uint32_t batteryRaw = 0;\n    for(uint8_t i = 0; i &lt; numSamples; i++)\n    {\n        batteryRaw += analogRead(batteryPin);\n    }\n    float voltage = 3.3 / 4095 * batteryRaw / numSamples;\n\n    // Measured voltage is less than true battery voltage, partly because of the\n    // voltage divider circuit, and partly because the ADC has a non-zero input\n    // current. This scaler was experimentally found to correct these effects,\n    // though the nominal value may differ between boards\n    voltage *= 1.688;\n\n    // Print battery voltage\n    numChars = sprintf(displayStr, \"%.3fV\", voltage);\n    printRow(2, displayStr, numChars);\n\n    // Display on OLED\n    oled.display();\n}\n\nvoid displaySyncRTC()\n{\n    // Check if screen needs to be updated\n    if(!updateScreen)\n        return;\n    updateScreen = false;\n\n    // Create text buffer\n    char displayStr[10] = {0};\n    uint8_t numChars = 0;\n\n    // Clear screen\n    oled.erase();\n\n    // Print RTC sync message\n    numChars = sprintf(displayStr, \"Sync RTC\");\n    printRow(0, displayStr, numChars);\n    numChars = sprintf(displayStr, \"with NTP?\");\n    printRow(1, displayStr, numChars);\n\n    // Display on OLED\n    oled.display();\n\n    // Check if user requested to synchronize RTC\n    if(userInput)\n    {\n        // Clear screen\n        oled.erase();\n\n        // Print RTC sync message\n        numChars = sprintf(displayStr, \"Syncing\");\n        printRow(0, displayStr, numChars);\n        numChars = sprintf(displayStr, \"RTC...\");\n        printRow(1, displayStr, numChars);\n\n        // Display on OLED\n        oled.display();\n\n        // Start connecting to WiFi network\n        WiFi.begin(ssid, password);\n        while(WiFi.status() != WL_CONNECTED)\n        {\n            Serial.println(\"Connecting to WiFi...\");\n            delay(1000);\n        }\n\n        // Sync with an NTP server\n        configTime(timeZone * 3600, 3600, \"pool.ntp.org\");\n\n        // Disconnect WiFi\n        WiFi.disconnect(true);\n        WiFi.mode(WIFI_OFF);\n\n        // Get updated time\n        struct tm timeinfo;\n        getLocalTime(&amp;timeinfo);\n\n        // Set RTC to current time\n        uint8_t time[TIME_ARRAY_LENGTH];\n        time[TIME_HUNDREDTHS] = rtc.DECtoBCD(millis());\n        time[TIME_SECONDS] = rtc.DECtoBCD(timeinfo.tm_sec);\n        time[TIME_MINUTES] = rtc.DECtoBCD(timeinfo.tm_min);\n        time[TIME_HOURS] = rtc.DECtoBCD(timeinfo.tm_hour);\n        time[TIME_DATE] = rtc.DECtoBCD(timeinfo.tm_mday);\n        time[TIME_MONTH] = rtc.DECtoBCD(timeinfo.tm_mon);\n        time[TIME_YEAR] = rtc.DECtoBCD(timeinfo.tm_year);\n        time[TIME_DAY] = rtc.DECtoBCD(timeinfo.tm_wday);\n        rtc.setTime(time, TIME_ARRAY_LENGTH);\n\n        // Clear screen\n        oled.erase();\n\n        // Print RTC sync message\n        numChars = sprintf(displayStr, \"RTC\");\n        printRow(0, displayStr, numChars);\n        numChars = sprintf(displayStr, \"Synced!\");\n        printRow(1, displayStr, numChars);\n\n        // Display on OLED\n        oled.display();\n    }\n}\n\n// Helper function to display text on rows 0-2\nvoid printRow(uint8_t row, char* text, uint8_t numChars)\n{\n    // Set cursor location so text is centered\n    oled.setCursor(midX - 5 * numChars / 2, rowHeight * row);\n\n    // Print text at cursor location\n    oled.print(text);\n}\n\n// Helper function to minimuze total current consumption and enter deep sleep\nvoid enterDeepSleep()\n{\n    // Turn off display\n    oled.erase();\n    oled.display();\n    oled.displayPower(false);\n\n    // Minimize current consumption of RTC\n    rtc.enableLowPower();\n    rtc.enableSleep();\n    rtc.writeRegister(RV1805_CTRL1, 0x77);\n\n    // Disable accelerometer interrupts, except double tap\n    accelerometer.enableInterrupt(BMA400_STEP_COUNTER_INT_EN, false);\n    accelerometer.enableInterrupt(BMA400_SINGLE_TAP_INT_EN, false);\n    // accelerometer.enableInterrupt(BMA400_DOUBLE_TAP_INT_EN, false);\n    accelerometer.enableInterrupt(BMA400_GEN1_INT_EN, false);\n    accelerometer.enableInterrupt(BMA400_GEN2_INT_EN, false);\n\n    // Could have had a new interrupt fire, read status to clear old interrupts\n    uint16_t interruptStatus = 0;\n    accelerometer.getInterruptStatus(&amp;interruptStatus);\n\n    // Set interrupt pin as wakeup source\n    esp_deep_sleep_enable_gpio_wakeup(BIT(interruptPin), ESP_GPIO_WAKEUP_GPIO_HIGH);\n\n    // Enter deep sleep. This never returns, instead the code restarts entirely\n    esp_deep_sleep_start();\n}\n\n// ISR for accelerometer interrupts\nvoid bma400InterruptHandler()\n{\n    // Set flag to be evaluated later\n    interruptOccurred = true;\n}\n</code></pre> <p>Now select the board (SparkFun ESP32-C6 Qwiic Pocket) and the Port and click the \"Upload\" button. Once the code finishes uploading, you should see a clock display on the Qwiic Micro OLED screen. </p>"},{"location":"smart_watch_example/#code-to-note","title":"Code to Note","text":"<p>The code has a few settings users should take note of to get the most out of the smart watch demo. Let's take a closer look.</p>"},{"location":"smart_watch_example/#bma400-settings","title":"BMA400 Settings","text":"<p>The code sets several thresholds on the BMA400 for tap/double-tap detection, step counting, and tilt-thresholds to fairly generous values to make all of the motion actions easy to trigger but some may find these to be too easily triggered. The code sets the BMA400's tap detection sensitivity to the max value (7) so if you want to make it less sensitive adjust this line:</p> <pre><code>.sensitivity = BMA400_TAP_SENSITIVITY_7,\n</code></pre>"},{"location":"smart_watch_example/#ntp-configuration","title":"NTP Configuration","text":"<p>Syncing the RTC to a NTP (Network Time Protocol) server requires an internet connection. The code has placeholders for these values so you'll need to enter your network credentials in the section of code shown below:</p> <pre><code>const char* ssid = \"your-ssid\";\nconst char* password = \"your-password\";\n</code></pre>"},{"location":"smart_watch_example/#smart-watch-actions","title":"Smart Watch Actions","text":"<p>The smart watch code includes a bunch of motion-triggered actions to change the OLED display so let's take a closer look at them to make sure we get the most out of our smart watch.</p>"},{"location":"smart_watch_example/#deep-sleep-wake-return","title":"Deep Sleep Wake &amp; Return","text":"<p>The code tells the circuit to enter deep sleep on two conditions: 60 seconds of inactivity or pressing the BOOT button on the bottom of the Qwiic Development Board. Double-tapping the watch wakes it from deep sleep and turns on the OLED to display the last screen viewed (default after upload is the analog clock).</p>"},{"location":"smart_watch_example/#tilt-functions","title":"Tilt Functions","text":"<p>The OLED display is off by default to help conserve battery power. It enables the display when you're \"checking your watch\" so try tilting it in \"towards\" you with the OLED screen upright (ribbon cable on the bottom) and the display should turn on like the photo below:</p> <p></p> <p>Tilt the screen \"away\" to turn the screen back off. Otherwise, screen should return to deep sleep after 60 seconds of inactivity (ie. no tilts or taps).</p>"},{"location":"smart_watch_example/#tap-menu-options","title":"Tap Menu Options","text":"<p>When the OLED is active you can tap on the screen (or just trigger a tap action for the BMA400 like setting the watch down or a similar action) to cycle through the four display options: Clock, Step Counter, Battery Voltage, and Sync with NTP Server.</p>"},{"location":"smart_watch_example/#analog-clock","title":"Analog Clock","text":"<p>This display is a simple analog clock interface without hour markings. It also features a nifty second counter signified by a dot travelling around the clock face.</p> <p></p>"},{"location":"smart_watch_example/#step-counter","title":"Step Counter","text":"<p>The smart watch code also takes advantage of the BMA400's built-in step counting feature. It displays steps counted as well as the current action: Standing, Walking, and Running.</p> <p></p>"},{"location":"smart_watch_example/#battery-voltage","title":"Battery Voltage","text":"<p>The third screen option shows the remaining battery voltage of a connected battery voltage to keep track of remaining charge on of an attached battery.</p> <p></p>"},{"location":"smart_watch_example/#sync-with-ntp-server","title":"Sync with NTP Server","text":"<p>The last display option lets you remotely sync the RTC with an NTP (assuming it has a WiFi connection) by double-tapping the display when \"Sync with NTP Server\" is displayed.</p> <p></p>"},{"location":"software_setup/","title":"Arduino Setup","text":"<p>Attention</p> <p>If this is your first time using Arduino, please read through our tutorial on installing the Arduino IDE. If you have not installed an Arduino library before, we recommend you check out our installation guide.</p> <p>With the Qwiic Pocket Dev Board connected to our computer, it's time to set up the boards package in Arduino.</p>"},{"location":"software_setup/#installing-espressif-arduino-boards","title":"Installing espressif Arduino Boards","text":"<p>The espressif ESP32 Arduino Boards package includes the Qwiic Pocket Development Board - ESP32-C6. Install it by opening the Boards Manager tab on the left side of the IDE, then search for \"espressif ESP32\" and install the latest version of the ESP32 boards package as the screenshot below shows. This assumes the use of Arduino 2.x and later. If you're on Legacy Arduino (1.8x and previous) can find the Boards Manager tool in File/Tools/Boards Manager.</p> <p></p>"},{"location":"software_setup/#espressif-idf","title":"espressif IDF","text":"<p>Users who prefer to use espressif's development toolkit, espressif IDF, can get started by following their instructions here and  ESP32-C6 specific documentation here. </p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#usb-cdc-on-boot-settings","title":"USB CDC on Boot Settings","text":"<p>Take note of the option labeled \"USB CDC on Boot\" when selecting the Board from the Tools menu. This option sets the serial outputs and defines their label for use in code. The SparkFun variants default to Enable USB CDC on boot which sets both <code>Serial</code> and <code>Serial0</code> as available serial ports. In this configuration, <code>Serial</code> corresponds to the direct USB/Serial converter on the chip (and the USB-C interface) and <code>Serial0</code> corresponds to the UART0 bus (default pins are 16 and 17).</p> <p>With either setting, <code>Serial1</code> is available and refers to the UART1 bus (default pins are 4 and 5).</p>"},{"location":"troubleshooting/#general-troubleshooting","title":"General Troubleshooting","text":"<p>Need Help?</p> <p>If you need technical assistance or more information on a product that is not working as you expected, we recommend heading over to the SparkFun Technical Assistance page for some initial troubleshooting.</p> <p> SparkFun Technical Assistance Page </p> <p>If you can't find what you need there, the SparkFun Forums is a great place to search product forums and ask questions.</p> <p>Account Registration Required</p> <p>If this is your first visit to our forum, you'll need to create a Forum Account to post questions.</p>"},{"location":"github/contribute/","title":"Help Improve the Experience!","text":"<p>Spot an improvement opportunity? Feel free to contribute to our open-source design and documentation. </p>"},{"location":"github/contribute/#enhance-our-documentation","title":"Enhance our Documentation","text":"<p>All of this documentation can be modified by you! Please help us make it better.</p> <ul> <li>These pages are contained in the <code>docs</code> folder of the SparkFun Qwiic Pocket Dev Board ESP32-C6 repository.</li> </ul>"},{"location":"github/contribute/#submit-a-correction","title":"Submit a Correction","text":"<ol> <li>Fork this repo</li> <li>Add your corrections or improvements to the markdown file</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the documentation specialist will automatically be notified.</li> <li>We will review your suggested improvements to make sure they are correct and fit within our documentation standards.</li> </ul> </li> </ol>"},{"location":"github/contribute/#upgrade-our-hardware-design","title":"Upgrade our Hardware Design","text":"<p>All of our designs are open-source! Please help us make it better.</p> <ul> <li>Our board design files are contained in the <code>Hardware</code> folder of the SparkFun Qwiic Pocket Dev Board ESP32-C6 repository.</li> </ul>"},{"location":"github/contribute/#submit-a-design-improvement","title":"Submit a Design Improvement","text":"<ol> <li>Fork this repo</li> <li>Add your design modifications</li> <li> <p>File a pull request with your changes, and enjoy making the world a better place.</p> <ul> <li>Once received, the engineer in charge of the original design will automatically be notified.</li> <li>We will review your suggested upgrades, if they are within our board design standards and meet our product design requirements, we will flag these changes for our next board revision.</li> </ul> <p>Note</p> <p>Please note, that even if your suggestion is accepted, these changes may not be immediate. We may have to cycle through our current product inventory first.</p> </li> </ol>"},{"location":"github/contribute/#contributors","title":"Contributors","text":"<p>Let's provide some recognition to those who have contributed to this project!</p> <p> </p>"},{"location":"github/file_issue/","title":"Did we make a mistake?","text":"<p>Spot something wrong? Please let us know. </p> <p>Attention</p> <p>This is not where customers should seek assistance on a product. If you require technical assistance or have questions about a product that is not working as expected, please head over to the SparkFun Technical Assistance page for some initial troubleshooting.  SparkFun Technical Assistance Page </p> <p>If you can't find what you need there, the SparkFun Forums is a great place to search product forums and ask questions.</p> <p>Account Registration Required</p> <p>If this is your first visit to our forum, you'll need to create a Forum Account to search product forums and post questions.</p>"},{"location":"github/file_issue/#discrepancies-in-the-documentation","title":"Discrepancies in the Documentation","text":"<p>All of this documentation can be modified by you! Please help us make it better.</p> <ul> <li>The documentation files for these pages are contained in the <code>docs</code> folder of the SparkFun Qwiic Pocket Dev Board ESP32-C6 repository.</li> </ul>"},{"location":"github/file_issue/#spot-something-wrong","title":"Spot something wrong?","text":"<p>If a section of the documentation is incorrect, please open an issue and let us know.</p>"},{"location":"github/file_issue/#do-you-have-a-suggested-correction","title":"Do you have a suggested correction?","text":"<ol> <li>With a GitHub account, fork this repo</li> <li>Add your correction(s) or improvement(s) to the markdown file(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the documentation specialist will automatically be notified.</li> <li>We will review your suggested improvement(s) to make sure they are correct and fit within our documentation standards.</li> </ul> </li> </ol>"},{"location":"github/file_issue/#problems-in-the-hardware-design","title":"Problems in the Hardware Design","text":"<p>All of our designs are open-source! Please help us make it better.</p> <ul> <li>Our board design files are contained in the <code>Hardware</code> folder of the SparkFun Qwiic Pocket Dev Board ESP32-C6 repository.</li> </ul>"},{"location":"github/file_issue/#does-something-not-make-sense","title":"Does something not make sense?","text":"<p>If part of the design is confusing, please open an issue and let us know.</p>"},{"location":"github/file_issue/#did-we-forget-to-include-an-important-function-of-the-board","title":"Did we forget to include an important function of the board?","text":"<ul> <li>Please keep in mind that we may intentionally exclude certain functions of the board to meet our product design requirements. (For example, our Qwiic Micro boards are intended to fit on a small board layout and only use I<sup>2</sup>C communication; therefore, we may not have the SPI and interrupt pins available for users.)</li> <li>If part of the board's functionality is missing, please open an issue and file a feature request.</li> </ul>"},{"location":"github/file_issue/#do-you-wish-to-contribute-directly-to-improving-the-board-design","title":"Do you wish to contribute directly to improving the board design?","text":"<ol> <li>With a GitHub account, Fork this repo</li> <li>Add your design improvement(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the engineer in charge of the original design will automatically be notified.</li> <li>We will review your suggested improvement(s), if they are within our board design standards and meet our product design requirements, we will flag these changes for our next board revision. (Please note, that even if your suggestion is accepted, these changes may not be immediate. We may have to cycle through our current product inventory first.)</li> </ul> </li> </ol>"}]}